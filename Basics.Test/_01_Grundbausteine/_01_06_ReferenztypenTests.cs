using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Basics.Test._01_Grundbausteine
{
    [TestClass]
    public class _01_06_ReferenztypenTests
    {

        Point P1;

        // Wird 
        SPoint S1; // Implizit wird aufgerufen: S1 = new SPoint();

        [TestMethod]
        public void _01_06_01_Referenztypen_vs_WertetypenTest()
        {

            // Eine Double- Konstante verhält sich wie ein Objekt -> Konsequenz aus der Aussage: im Kern ist alles ein Object

            {
                var txt = (3.14).ToString();


                // P1 hat jetzt den Wert Nothing <=> noch kein Objekt vorhanden !
                Assert.IsNull(P1);

                // Folgende Anweisung führt zu einem Laufzeitfehler
                try
                {
                    P1.X = 20.0;
                }
                catch (Exception ex)
                {

                }

                //Objekt im Heapspeicher mittels New- Operator erzeugen
                P1 = new Point();

                // Jetzt zeigt p1 auf was ...
                Assert.IsNotNull(P1);

                // ... und der Zugriff gelingt
                P1.X = 10.0;
                P1.Y = 20.0;

                // Achtung: hier entsteht keine Kopie: P1_Kopie und P1 zeigen auf dasselbe Objekt
                Point P1_Kopie = P1;

                P1_Kopie.X += 100;
                Assert.AreEqual(P1_Kopie.X, P1.X);

                // Anlegen der Kopie "zu Fuss"
                P1_Kopie = new Point();
                P1_Kopie.X = P1.X;
                P1_Kopie.Y = P1.Y;

                // ... automatisiert mit Clone- Methode

                var PClonbar = new PointClonbar(33, 44);

                PointClonbar PClonbar_Kopie = (PointClonbar)PClonbar.Clone();


                // Aber !!!
                // p2 zeigt auf was, obwohl kein Objekt mittels New angelegt wurde (Automatik)
                // Das ist der Unterschied zwischen Class und Structure !
                Assert.IsNotNull(S1);
                S1.X = -20.0;

                // Strukturen können wie Klassen über mehrere Konstruktoren verfügen
                var S2 = new SPoint(33, 44);
                S2.Y += S1.X;

                // Achtung: bei Strukturen erfolgt tatsächlich ein Kopieren
                SPoint S3 = S1;


                S3.X += 100;
                Assert.AreEqual(S3.X, 80);
                Assert.AreEqual(S1.X, -20);
            }
        }


        double ADD(object a, object b)
        {
            // Achtung: Unboxing führt bei übergabe 
            // von Integer- Objekten zu einer InvalidCastException
            return (double)a + (double)b;
        }

        double ADD_mit_korrektem_Unboxing(object a, object b)
        {
            // Achtung: Unboxing führt bei übergabe 
            // von Integer- Objekten zu einer InvalidCastException
            if (a is double && b is double)
                return (double)a + (double)b;
            else if (a is int && b is int)
                return (double)((int)a + (int)b);
            else if (a.GetType() == typeof(string) && b.GetType() == typeof(string))
            {
                return double.Parse((string)a + (string)b);
            }
            else
                throw new InvalidCastException();
        }

        // Anstatt Funktionen mit objekt- Parametern sollte man
        // Funktion überladen

        double ADD_Overloaded(double a, double b)
        {
            return a + b;
        }

        double ADD_Overloaded(float a, float b)
        {
            return a + b;
        }

        double ADD_Overloaded(int a, int b)
        {
            return a + b;
        }

        double ADD_Overloaded(decimal a, decimal b)
        {
            return (double)(a + b);
        }


        [TestMethod]
        public void _01_06_02_Boxing_Unboxing()
        {
            // Situation, in der ein primitiver Wertetyp wie ein Objekt behandelt wird
            // Aus nummersichen Wert wird eine Zeichenkette mit einer Währungsangabe
            var txt = (3.14).ToString("C");

            object obj3_14 = 3.14;
            var txt2 = obj3_14.ToString();

            System.Double s3_14 = 3.14;

            // Hier findet wieder ein Boxing statt
            var txt3 = s3_14.ToString("C");


            // Konsequenzen des Boxings:
            var ListeKlassisch = new System.Collections.ArrayList();  // stammt aus .NET 1.0. Kann nur Referenzen vom Typ object verwalten

            // Hier findet implizit ein Boxing statt
            // Eintrag in der Arraylist ist kein double, sondern Objektbox für double
            // -> höherer Speicherplatzverbrauch
            ListeKlassisch.Add(3.14);

            // Beim Zugriff ist unboxing notwendig
            // -> höherer Bedarf an Rechenleistung
            double wertAusList = (double)ListeKlassisch[0];



            // double
            Assert.AreEqual(5.0, ADD(2.0, 3.0));

            // Integer
            try
            {
                ADD(2, 3);
            }
            catch (Exception ex)
            {
            }

            Assert.AreEqual(5.0, ADD_mit_korrektem_Unboxing(2.0, 3.0));

            Assert.AreEqual(5.0, ADD_mit_korrektem_Unboxing(2, 3));

            Assert.AreEqual(2.3, ADD_mit_korrektem_Unboxing("2,", "3"));

            try
            {
                ADD_mit_korrektem_Unboxing(2M, 3M);
            }
            catch (Exception ex)
            {
            }

            var sum0 = ADD_Overloaded(2.0, 3.0);

            var sum1 = ADD_Overloaded(2.0f, 3.0f);

            var sum2 = ADD_Overloaded(2, 3);

            var sum3 = ADD_Overloaded(2.0M, 3.0M);

            //var sum4 = ADD_Overloaded("3,14", "2,72");



        }

    }
}
